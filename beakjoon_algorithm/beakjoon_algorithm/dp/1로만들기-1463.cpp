/*
문제 해결 방법
 1) N/3
 N개에서 1까지의 연산에 따라 최소 횟수를 구해야한다.
 따라서 N개에서 N/3 으로 가는 연산의 횟수는 1
 N/3 에서 -> 1로 가는 연산의 횟수는 N/3
 총 연산의 횟수는 N/3 + 1
 
 2) N/2
 N개에서 N/2 으로 가는 연산의 횟수는 1
 N/2 에서 -> 1로 가는 연산의 횟수는 N/2
 총 연산의 횟수는 N/2 + 1
 
 3) N-1
 N개에서 N-1 으로 가는 연산의 횟수는 1
 N-1에서 -> 1로 가는 연산의 횟수는 N-1
 총 연산의 횟수는 N-1 + 1

 1), 2), 3) 의 총 연산의 횟수
 
 4) 메모이제이션
 이제 이렇게 연산을 해야한다는 것을 알았으니 우리가 DP값을 이용하여
 반환을 어떻게 받을지 생각해줘야한다.
 DP에 있는 값이 > 0 보다 클 경우에 값이 있는것이므로 그 데이터만 반환 시켜줘야한다.
 메모이제이션으로 불필요한 메모리 낭비를 막기 위함
 그러면, return 값으로 dp[n]값으로 해주면 된다.
 
 5) 재귀호출을 종료시키기 위한 조건
 먄약 들어온 N의 값이 1일 경우에는 프로그램을 종료 시킨다. 그이유는 1을 이미 구했기 때문에
 
 6) 시간복잡도
 
 1),2),3)에서 설명한것과 같이 N에서 N/3, N/2, N-1 로 가는 복잡도는 각각 1씩이다
 총 3인경우인데, 이것은 O(1)로 시간복잡도를 표현 할 수 있다.
 그리고, 전체데이터의 개수는 N개 만큼이므로 O(N)의 시간복잡도가 걸린다.
 
 여기서 보면 10^6의 경우 1,000,000 백만까지의 시간복잡도를 가지게 되므로
 O(N)+O(1)의 복잡도가 성립하는것을 알 수 있다.
 
 만약 O(N^2)의 시간복잡도가 나타나게 될 경우 O(1,000,000^2)가 되어
 1,000,000,000,000 1조의 시간복잡도가 나타나는것을 알 수 있다.
*/
#include <stdio.h>
#include <iostream>
using namespace std;
int dp[1000001];
int recursive(int n){
    
    // 1이 완성된 경우
    if(n == 1){
        return 1;
    }
    // 값 있을 경우
    if(dp[n] > 0){
        // 메모이제이션
        return dp[n];
    }
    // -1의 경우는 따로 조건이 없으므로 바로 계산.
    dp[n] = dp[n-1] + 1;
    // n/3
    if(n % 3 ==0){
        // 최소 값이 있을 경우 Swap
        int temp = dp[n/3] + 1;
        if(dp[n] > temp){
            dp[n] = temp;
        }
    }
    // n/2
    if(n % 2 == 0){
        // 최소 값이 있을 경우 Swap
        int temp = dp[n/2] + 1;
        if(dp[n] > temp){
            dp[n] = temp;
        }
    }
    return dp[n];
}
int main(void){
    int n;
    cin >> n;
    int result = recursive(n);
    cout << result;
    
    return 0;
}

